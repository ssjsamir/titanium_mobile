/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2019 by Axway. All Rights Reserved.
 * Licensed under the terms of the Apache Public License.
 * Please see the LICENSE included with this distribution for details.
 */

'use strict';

console.log('Running Titanium "prebuild.js" script.');

const util = require('util');
const exec = util.promisify(require('child_process').exec); // eslint-disable-line security/detect-child-process
const fs = require('fs-extra');
const glob = util.promisify(require('glob'));
const path = require('path');
const timestamp = require('../../build/lib/utils').timestamp;

// Determine if we're running on a Windows machine.
const isWindows = (process.platform === 'win32');

/**
 * Double quotes given path and escapes double quote characters in file/directory names.
 * @param {String} filePath The path to be double quoted.
 * @return {String} Returns the double quoted path.
 */
function quotePath(filePath) {
	if (!filePath) {
		return '""';
	}
	if (!isWindows) {
		filePath = filePath.replace(/"/g, '\\"');
	}
	return `"${filePath}"`;
}

/**
 * Executes the "gperf" command line tool used to generate a C/C++ file with perfect hashes.
 * @param {String} workingDirPath The directory which all paths will be relative to. Cannot be null.
 * @param {String} inputFilePath Path to the C/C++ file template used to generate the output file with perfect hashes.
 * @param {String} outputFilePath File name and path to the file to be generated by the gperf tool.
 */
async function gperf(workingDirPath, inputFilePath, outputFilePath) {
	// Acquire a path to the "gperf" command line tool.
	let gperfPath = 'gperf';
	if (isWindows) {
		gperfPath = quotePath(path.join(__dirname, '..', '..', 'build', 'win32', 'gperf'));
	}

	// Run the "gperf" command.
	const commandLine = gperfPath + ' -L C++ -E -t ' + quotePath(inputFilePath);
	const { stdout, stderr } = await exec(commandLine, { cwd: workingDirPath });
	if (stderr) {
		throw new Error(`"gperf" failed to process file "${inputFilePath}". Reason: ${stderr}`);
	}
	await fs.writeFile(outputFilePath, stdout);
}

/** Generates a "build.properties" file under "assets" providing Titanium SDK's build version and time. */
async function generateBuildProperties() {
	// This function escapes the "value" string in a property key=value pair.
	function escapeValue(stringValue) {
		if (stringValue) {
			stringValue = stringValue.replace(/\\/g, '\\\\');
			stringValue = stringValue.replace(/:/g, '\\:');
			stringValue = stringValue.replace(/[\r\n]/g, '');
			stringValue = stringValue.replace(/[\u0080-\uFFFF]/g, (match) => {
				return '\\u' + ('0000' + match.charCodeAt(0).toString(16)).slice(-4);
			});
		}
		return stringValue;
	}

	// Fetch Titanium SDK's build version and git hash from environment variables.
	let buildVersion = process.env.TI_SDK_BUILD_VERSION;
	if (!buildVersion) {
		buildVersion = '1.0.0';
	}
	let buildGitHash = process.env.TI_SDK_BUILD_GIT_HASH;
	if (!buildGitHash) {
		buildGitHash = 'HEAD';
	}

	let buildTimestamp = process.env.TI_SDK_BUILD_TIMESTAMP;
	if (!buildTimestamp) {
		buildTimestamp = timestamp();
	}

	// Create the "build.properties" content.
	const fileContentString
		= '#Generated by Titanium\n'
		+ '\n'
		+ 'build.version=' + escapeValue(buildVersion) + '\n'
		+ 'build.githash=' + escapeValue(buildGitHash) + '\n'
		+ 'build.timestamp=' + escapeValue(buildTimestamp) + '\n';

	// Create the "build.properties" file under the "assets" directory.
	const directoryPath = path.join(__dirname, 'assets', 'Resources', 'ti.internal');
	const filePath = path.join(directoryPath, 'build.properties');
	await fs.mkdirs(directoryPath);
	await fs.writeFile(filePath, fileContentString);
}

/** Generates C/C++ source files containing internal JS files and from gperf templates. */
async function generateSourceCode() {
	// Generate a "KrollNativeBindings.h" file with perfect hashes via gperf tool.
	// Note: 2nd argument is inserted into file as-is. Use relative path since absolute may contain user name.
	const runtimeV8DirPath = path.join(__dirname, '..', 'runtime', 'v8');
	await fs.mkdirs(path.join(runtimeV8DirPath, 'generated'));
	await gperf(
		runtimeV8DirPath, 'src/native/KrollNativeBindings.gperf',
		path.join(runtimeV8DirPath, 'generated/KrollNativeBindings.h'));

	// Fetch the "python" command line tool to use. Prefer "python2" if available.
	// TODO: Replace our usage of python to make it easier to build on Windows.
	let pythonCommand = 'python';
	if (!isWindows) {
		try {
			await exec('type python2 > /dev/null');
			pythonCommand = 'python2';
		} catch (ex) {
			// The "python2" command line tool does not exist on this system.
		}
	}

	// Create "bootstrap.js" which generates create*() functions for all Titanium internal modules.
	// TODO: Replace our usage of python to make it easier to build on Windows.
	await exec(pythonCommand + ' ' + quotePath(path.join(runtimeV8DirPath, 'tools', 'genBootstrap.py')) + ' --runtime=v8');

	// Generate a "KrollGeneratedBindings.h" file with perfect hashes via gperf tool.
	// Note: 2nd argument is inserted into file as-is. Use relative path since absolute may contain user name.
	await gperf(
		runtimeV8DirPath, 'generated/KrollGeneratedBindings.gperf',
		path.join(runtimeV8DirPath, 'generated/KrollGeneratedBindings.h'));

	// Fetch all JS file paths under directory: "./runtime/common/src/js"
	const runtimeCommonDirPath = path.join(__dirname, '..', 'runtime', 'common');
	let filePaths = await glob(
		'*.js',
		{
			cwd: path.join(runtimeCommonDirPath, 'src', 'js'),
			realpath: true
		}
	);

	// Fetch all JS file paths under each module directory: "./modules/<ModuleName>/src/js"
	filePaths = filePaths.concat(await glob(
		'*/src/js/*.js',
		{
			cwd: path.join(__dirname, '..', 'modules'),
			realpath: true
		}
	));

	// Generate a "KrollJS.h" file containing all of the above fetched JS files.
	// TODO: Replace our usage of python to make it easier to build on Windows.
	const commandLineArgs = [
		pythonCommand,
		quotePath(path.join(runtimeV8DirPath, 'tools', 'js2c.py')),
		quotePath(path.join(runtimeV8DirPath, 'generated', 'KrollJS.h')),
		quotePath(path.join(runtimeV8DirPath, 'generated', 'bootstrap.js'))
	];
	for (const nextPath of filePaths) {
		commandLineArgs.push(quotePath(nextPath));
	}
	await exec(commandLineArgs.join(' '));
}

/** Executes the pre-build step. */
async function main() {
	// Run the following operations in parallel.
	await Promise.all([
		// Generate a "build.properties" file providing the Titanium SDK's version and other info.
		generateBuildProperties(),

		// Generate C/C++ source files with JS files embedded in them and from gperf templates.
		generateSourceCode()
	]);
}

main()
	.then(() => process.exit(0))
	.catch((err) => {
		console.error(err);
		process.exit(1);
	});
